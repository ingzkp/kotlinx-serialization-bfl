mod floating_point_100_20;

use floating_point_100_20::Amount;
use floating_point_100_20::AMOUNT_LENGTH;
use floating_point_100_20::AMOUNT_QUANTITY_LENGTH;
use floating_point_100_20::AMOUNT_TOKEN_NAME_HASH_LENGTH;
use floating_point_100_20::AMOUNT_TOKEN_NAME_HASH_LENGTH_LENGTH;
use floating_point_100_20::BIG_DECIMAL_FRACTION_LENGTH;
use floating_point_100_20::BIG_DECIMAL_FRACTION_LENGTH_LENGTH;
use floating_point_100_20::BIG_DECIMAL_INTEGER_LENGTH;
use floating_point_100_20::BIG_DECIMAL_INTEGER_LENGTH_LENGTH;
use floating_point_100_20::BIG_DECIMAL_LENGTH;
use floating_point_100_20::BIG_DECIMAL_SIGN_LENGTH;
use floating_point_100_20::BigDecimal;
use floating_point_100_20::get_int;
use floating_point_100_20::get_long;
use floating_point_100_20::INPUT_LENGTH;

const AMOUNTS_LENGTH_LENGTH: u8 = 4;
const AMOUNTS_MAX_LENGTH: u8 = 4;

fn main(input: [u8; INPUT_LENGTH]) -> Amount {
    let length = get_int(input, 0 as u16);
    let big_decimal_zero: BigDecimal = BigDecimal {
        sign: 0 as i8,
        integer: [
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ],
        fraction: [
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ]
    };
    let mut amounts: [Amount; AMOUNTS_MAX_LENGTH] = [
        Amount {
            quantity: 0 as i64,
            display_token_size: BigDecimal::zero(),
            token_name_hash: [0; AMOUNT_TOKEN_NAME_HASH_LENGTH]
        };
        AMOUNTS_MAX_LENGTH
    ];

    for i in 0..AMOUNTS_MAX_LENGTH while i as u32 < length {
        amounts[i] = Amount::deserialize_amount(input, AMOUNTS_LENGTH_LENGTH as u16 + i as u16 * AMOUNT_LENGTH as u16);
    }

    let mut max: Amount = amounts[0];
    for i in 0..AMOUNTS_MAX_LENGTH while i as u32 < length {
        if (amounts[i].quantity > max.quantity) {
            max = amounts[i];
        }
    }

    max
}